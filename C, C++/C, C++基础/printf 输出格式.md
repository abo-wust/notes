
以Ubuntu发行版本的Linux 18.04 x86_64，gcc 7.5.0为例

_注：16位系统的类型长度待完善_

### 数据类型

**整数类型**

|数据类型|16位系统|32位系统|64位系统|
|----|----|----|----|
|char|1|1|1|
|unsigned char|1|1|1|
|signed char|1|1|1|
|short|2|2|2|
|unsigned short|2|2|2|
|int|2|4|4|
|unsigned int|2|4|4|
|long(long int)|4|4|8|
|unsigned long|4|4|8|
|long long|8|8|8|


**派生类型**

|数据类型|16位系统|32位系统|64位系统|
|----|----|----|----|
|指针（int \*或char \*)||4|8|


**浮点类型**

|数据类型|16位系统|32位系统|64位系统|精度|
|----|----|----|----|---|
|float|4|4|4|7位有效位，小数点后6位有效|
|double|8|8|8|16位有效位，小数点后15位有效|
|long double||12|16|20位有效位，小数点后19位有效|

关于long double的长度问题，`sizeof(long double)`在x86_64系统上使用gcc编译是16个字节，但是也与系统和编译工具有关
参考：
https://stackoverflow.com/questions/68723412/what-is-the-exact-range-of-long-double-in-c
https://en.wikipedia.org/wiki/Extended_precision

关于浮点型的精度问题，一般情况下可以按上述表格的说明理解，但是当数值特别大时，表格中所谓的小数点后几位有效不再适用。

详细解释分别参考：
https://en.wikipedia.org/wiki/Single-precision_floating-point_format
https://en.wikipedia.org/wiki/Double-precision_floating-point_format
https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format

其他：
https://www.cs.yale.edu/homes/aspnes/pinewiki/C(2f)FloatingPoint.html




### printf输出格式

printf()函数声明：
```
int printf (const char *__restrict __fmt, ...)
```

|格式字符|意义|
|----|----|
|a, A|以十六进制形式输出浮点数(C99 新增)。<br>实例 printf("pi=%a\n", 3.14); 输出 pi=0x1.91eb86p+1。如果使用%A，则输出大写字母|
|d|以十进制形式输出带符号整数(正数不输出符号)|
|o|以八进制形式输出无符号整数(不输出前缀0)|
|x, X|以十六进制形式输出无符号整数(不输出前缀0x，选择输出大小写)|
|u|以十进制形式输出无符号整数|
|f|以小数形式输出单、双精度实数|
|e, E|以指数形式输出单、双精度实数|
|g, G|以%f或%e中较短的输出宽度输出单、双精度实数|
|c|输出单个字符|
|s|输出字符串|
|p|输出指针地址|
|lu|32位无符号整数long。64bit系统上为64位无符号整数|
|llu|64位无符号整数long long|


除了上述表示输出数据类型的格式外，还有一些用来指定特殊格式的标识

|flags（标识）|描述|
|----|----|
|-|在给定的字段宽度内左对齐，默认是右对齐。实例printf("%-20s\\n", str_buf)，如果字符串str长度小于20，则左对齐，剩余长度空格填充|
|+|强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。|
|空格|如果没有写入任何符号，则在该值前面插入一个空格。|
|#|与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。<br> 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。<br> 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。|
|0|在指定填充 padding 的数字左边放置零（0），而不是空格。<br>实例：printf("%03d\\n", 1)，输出001|



|width（宽度）|描述|
|---|---|
|(number)|要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。例：printf("%20d\\n")|
|\*|指定输出宽度，与(number)需要在格式中指定不同，` * `需要在参数中使用`int`类型的前一个参数指定|

|.precision（精度）|描述|
|---|---|
|.number|对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。<br>对于 e、E 和 f 说明符：要在小数点后输出的小数位数。<br>对于 g 和 G 说明符：要输出的最大有效位数。<br>对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。<br>对于 c 类型：没有任何影响。<br>当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。|
|.\*|精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。|


**(number)使用示例：**
```
printf("%3d\n", 12);
printf("%.3d\n", 12);
printf("%.3d\n", 12222);
```

输出：
```
 12
012
12222
```
指定输出宽度为3，而待输出的参数为12时，宽度仅为2，小于指定输出宽度，所以用空格或者` 0 `来填充。如果指定宽度前有小数点` . `来修饰，则用` 0 `填充，否则用空格填充（如精度表格所述）。

指定输出宽度为3，而待输出的参数为12222时，宽度为5，大于指定输出宽度，所以不需要用空格或者` 0 `来填充。


**` * `星号使用示例：**
```
printf("%.*d\n", 2, 123);
printf("%.*d\n", 5, 1234);
printf("%.*d %.*d\n", 10, 12, 5, 3);

char *str = "programmer";
printf("str=%.*s\n", 6, str);
printf("str=%.*s\n", 20, str);
printf("str=%*s\n", 20, str);
```

输出：
```
123
01234
0000000012 00003
str=progra
str=programmer
str=          programmer
```

第一行输出，指定输出格式` %.*d `，表示以十进制整数形式输出带符号的整数。后面的两个参数`2`和` 123 `，分别表示指定输出宽度和待输出的整数。而指定输出宽度小于待输出整数的自身宽度，所以输出显示` 123 `。

第二行输出，指定输出格式与第一行相同，但是指定输出宽度为`5`，而待输出整数自身实际宽度为` 4 `，小于指定输出宽度，所以输出显示需要用` 0 `填充，显示为` 01234 `。

第二段代码用来输出显示字符串，星号的意义与第一段输出整数相同。当待输出字符串实际长度大于指定宽度时，输出的字符串会被截断显示，如示例显示，字符串实际长度为10，但是指定输出宽度仅为6，所以输出只显示6个字符`progra`。

第二段代码的后两行输出用来演示小数点在字符串输出中的作用。在第一段输出整数的代码中，小数点表示需要填充时用数字`0`，否则默认空格填充。而在字符串的输出中，加小数点无法用`0`来填充，输出显示的字符串宽度就是字符串自身实际长度。如果不加小数点，那么当字符串实际长度小于指定输出宽度需要填充时，默认使用空格填充。



|length（长度）|描述|
|---|---|
|h|参数被转换为短整型short或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。|
|l|参数被转换为长整型long或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。|
|ll|参数被转换为64位长整型long long或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。|
|L|参数被转换为长双精度型long double（仅适用于浮点数说明符：e、E、f、g 和 G）。|


### PRId64 / PRIu64

32位操作系统和64位操作系统上部分数据类型长度不同，在使用长度输出格式时会出现错误。比如，长整型`long`在32位操作系统上长度为4个字节，在64位操作系统上则是8个字节长度。printf输出一个32位长度的变量时，输出格式时使用`ld`或者`lu`，而相同代码在64位操作系统上运行，那么在使用`lu`或者`ld`来输出同一个32位长度的变量时，会出现异常，严重的会导致程序崩溃。

> int64_t 在 Linux 64-bit 操作系统 printf 输出格式要用 %ld
int64_t 在 Linux 32-bit 操作系统 printf 输出格式要用 %lld
uint64_t 在 Linux 64-bit 操作系统 printf 输出格式要用 %lu
uint64_t 在 Linux 32-bit 操作系统 printf 输出格式要用 %llu

所以，为了在不同位长的操作系统上能使用一个通用的printf输出格式，C99在头文件`intyypes.h`中提供了各种宏定义，比如`PRId32`、`PRId64`、`PRIu32`和`PRIu64`等。

示例：
```
int32_t a;
uint64_t b;
printf("a=%" PRId32 ", b=%" PRIu64 "\n", a, b);
```

在32位操作系统上编译执行时，宏`PRId32`展示形成字符串 `d` 宏`PRIu64`展示形成字符串`llu`：
```
printf("a=%d, b=%llu"\n", a, b);
```

在64位操作系统上编译执行时，宏`PRId32`展示形成字符串 `d` 宏`PRIu64`展示形成字符串`lu`：
```
printf("a=%d, b=%lu"\n", a, b);
```














