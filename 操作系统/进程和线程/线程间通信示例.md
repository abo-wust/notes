
### 问题：

有两个线程，其中线程1不停生成计算结果，生成一次大约需要50ms时间，当生成结果完成时，需要通知线程2立即对生成结果处理，，

目前是设置了一个全局变量，当生成结果完成时，线程1将全局变量置为True，第二个线程用while死循环来监视全局变量，当全局变量变为True时，立即对生成结果处理，处理大约需要5ms时间，处理完成后，再将全局变量置为False，，

但是感觉线程2用while死循环特别占时间片资源，影响其他线程执行效率，所以想知道有没有其他的办法。。。

（对了，如果把线程2的while(1){...}改成while(1){usleep(1000);...}）能较大程度降低线程2对时间片的占用吗？）

除了这两个线程还有其他的线程，，，


### 分析：

第一，同一个进程内部的线程间不存在通信问题，想怎么访问怎么访问；所以我们反而需要做一些事，从而主动“隔离”不同线程，避免数据脏读脏写。

第二，多线程编程（以及多进程编程）都需要操作系统方面的底子。不懂操作系统，多线程协作是做不好的。

具体到你这个案例上，简单说，不要轮询。

轮询这个动作本身就决定了，你的程序必定CPU占用奇高、发热巨大，同时运行缓慢。

这还是程序逻辑过于简单；稍微复杂一点，你这种写法，最终必然是“CPU占用跑满，程序逻辑寸步不前”，和一个死循环的垃圾没有什么差别。

第一步，先设置一个全局的、标准的锁（mutex）。

注意，第一个线程要修改内存数据，需要先申请锁，确保第二个线程不在读取数据；

第二个线程发现数据可用，也要先申请锁，确保第一个线程不会继续修改它。

也就是类似你过去那个“全局变量”的作用；但一定要使用标准的锁、使用标准的acquire系统调用申请锁数据读写权限。

这是因为，标准的mutex是操作系统提供的；当你的某个线程申请mutex失败时，操作系统会把它置于等待队列，在mutex可用前不会继续给它分配时间片，这就避免了忙等；而一旦mutex可用，这个线程就会被移回就绪队列，之后就可能获得时间片了。

这就避免了大量无效的CPU占用。

第二步，认真分析业务逻辑，画出两个线程的状态切换图，确定锁应该有几个、分别是什么状态（比如是否需要读写锁）；确保“线程申请到锁就一定可以执行；线程无法执行就一定要进入挂起状态”。

注意，你并不能确定什么时候第二个线程正在读取数据、或者阻塞在哪里长时间没有读取。所以你必须使用足够多的标志位，确保“数据未初始化、数据初始化中、数据初始化完成等待读取、数据读取中、数据读取完成”等状态可清晰区分。否则，数据就可能丢失（线程一产生数据后，线程二尚未得到调度，线程一又用新数据覆盖了之前的数据）或者出现脏读、脏写。

当然，视业务需要，只有true/false两个状态的锁也许已经够用了，但你必须认真评估、充分讨论之后再这么做——你的问题描述过于简略，无法确定是否能行。

第三步，重新设计共享数据结构，把“锁定时间”降到最低。

从你的描述中可知，线程1是不能停的，需要“不断的生成计算结果”；但如此一来……

而mutex的默认行为是：申请不到锁，就把申请锁的线程挂起。

于是，线程1生成计算结果时，线程2只能等着；而线程2处理计算结果那5ms，线程1也只能等着……

万一操作系统再安排不了时间片，那线程1可能就得等200ms，线程2才得到执行权；线程2执行时，线程1进了等待队列，等线程2释放锁，线程1才移回就绪队列，又等了200ms才得以执行……也就是出现了一个400ms以上的大卡顿。

这样搞的话，你其实根本就不应该用什么多线程。直接放在同一个线程里，收集50ms的数据，然后执行5ms的处理——简单，又不容易出错，效率高，响应快……

想要借多线程提高吞吐率，那么就必须搞一个更好用的数据结构。比如，一个**链表**。

链表的每个节点足够容纳50ms的数据；线程1先申请一个节点，把数据写进去，写50ms后，申请这个全局链表的锁，把数据挂进链表——锁定期间只需执行一条把链表末端next指向新节点的操作（可能还需要维护一下头尾指针，不要每次都顺着链表摸到尾）。

类似的，线程2被调度后，申请锁定链表，然后把链条第一个节点移除、指针记录在本地，随即释放锁；然后就可以不受打扰的处理这个节点携带的数据了。

注意，这时候，如果还用最简单的mutex的话，因为所有关于数据结构（链表）的操作都需要先锁定，再检查有无数据；那么线程2可能就会死循环的不停上锁、检查发现没数据，释放锁，然后马上又上锁……也就是绝大部分执行时间都在加解锁上。


所以，这时候我们就不得不搞一个更复杂的东西，比如，让mutex包含多个值。

当mutex非0时，线程2才可以从链表取出节点、同时把mutex值减一，减到0线程2就必须休眠，不要再去访问链表；而线程1每成功往链表加入一个节点，就把mutex值加一……

但这时候，由于线程1/2的读写可能很频繁，如果锁定之后才读写数据的话，那么锁定时间就会是50ms/5ms，允许另一个线程访问的时间就会特别特别短（比如每50ms/5ms解锁若干个ns，也就是超过90%以上的时间里数据都在锁定状态）；这时候另一个线程实际上是拿不到数据的，因为操作系统必须恰巧在第一个线程解锁后的若干纳秒里切换时间片、且刚好轮到它运行——除非其中一个线程一口气把缓冲区写满、或者把所有缓冲数据处理完然后陷入阻塞，否则另一个线程可能永远得不到执行机会。这就是术语说的“饿死”，是必须避免的。

因此，请优化算法、优化数据结构，把数据准备/处理放在锁定时间之外。如此一来，锁定后可以只处理一下next/head/tail指针，把节点挂入/取下，然后就马上释放锁。

换句话说，只有想办法把共享数据弄的“在大部分时候可用”，两个线程才能协作起来。

以上完成后，你可以进一步把这个共享数据结构实现成一个通用的、支持多线程访问的队列，只允许通过pop/push接口访问数据；同时把加解锁放到这两个接口里，从而简化使用逻辑，杜绝错误访问。

事实上，这个案例可能还可以进一步优化。

比如，如果只有这么两个线程，且线程1是生产者线程2是消费者（单生产者/消费者模型），那么这里甚至可以不用锁，实现一个标准的环形数组即可——这也是经典的、最简化的无锁编程案例。

当然，这样做之前，请确认你的软件运行平台（CPU）明确声明“指针访问是原子操作”，否则……

如果参与者更多、逻辑更复杂，那么锁就是必需的；甚至读写锁、旗语、event等东西都必须全面利用起来。

这个就太复杂了，这里一时讲不清，看操作系统原理的相关章节。


