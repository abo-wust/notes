
### C

1. const的含义，作用有哪些，谈一谈你对const的理解？
    
    https://blog.csdn.net/little_rookie__/article/details/111873494
    - 含义：只要一个变量前用const来修饰，就意味着该变量里的数据只能被访问，而不能被修改，也就是意味着“只读”（readonly）。
    - 作用：
        （1）可以用来修饰变量，修饰函数参数，修饰函数返回值，且被const修饰的东西，都受到强制保护；
        （2）使编译器保护那些不希望被修改的参数，防止其被无意的代码修改；
    - const常变量只在编译期有用，在运行期无用。
    - 现代C编译器(如vc、gcc)中的const将具有全局生命周期（如全局变量，static属性的变量）存储于只读存储区，修改该变量时将导致程序崩溃。【注意】标准C语言编译器（如bcc）不会被const修饰的全局变量存储于只读存储区，而是存储于可修改的全局数据区，其值依然可以改变。
    - C语言中，使用const修饰了一个变量，该变量不能直接修改，但是我们可以通过拿到这个变量的地址，然后通过它的地址来修改它。
    - 如果const修饰的是文字常量区的常量，如字符串常量，那这个是无法修改的。


2. 描述int \*p、const int \*p、int const \*p、int\* const p、const int\* const p的区别？
    - int \*p：一个指向整型的指针。
    - const int \*p：一个指向整型常量的指针。\*p是一个整型的常量，由const修改，所以不可修改，但是p本身可以修改。（==常量指针==）
    ```
        int a = 5;
        const int *p = &a;
        //*p = 10;   //error: assignment of read-only variable ‘p’
        printf("p=%x, %x, %x\n", *p, &a, p);
        
        输出：
        p=5, 47cd24dc, 47cd24dc
    ```
     
    - int const \*p：一个指向整型的常量指针。const修饰的是\*p，所以\*p不可修改，但是指向的地址p可以修改，所以可以通过修改a或b的值来达到修改\*p的目的。（==常量指针==）
    ```
        int a = 5;
        int b = 6;
        int const *p;
    
        p = &a;
        //*p = 100;   //error: assignment of read-only variable ‘p’
        printf("p=%d, %x, %x\n", *p, p, &a);
    
        p = &b;
        printf("p=%d, %x, %x\n", *p, p, &a);
        
        输出：
        p=5, abb12af8, abb12af8
        p=6, abb12afc, abb12af8
    ```
    
    - int \*const p：一个指向整型的指针常量。指针p本身是一个常量，指向一个整型后不能再指向其他地址，但是地址报错的整型变量是可以修改的。示例，指针p指向变量a的地址后不能再修改为指向b，但是指针p指向的整型变量\*p可以修改为100。（==指针常量==）
    ```
        int a = 5;
        int b = 6;
        int *const p = &a;
        //p = &b;   //error: assignment of read-only variable ‘p’
        *p = 100;
        printf("p=%d, %x, %x\n", *p, &a, p);
    ```
  
    - const int \*const p：一个指向整型常量的常量指针。这种类型的声明必须进行初始化，编译可能不会报错，但是不能修改指针，也不能修改指针指向的数据变量，定义也就没有意义。（==指向常量的常指针==）
    ```
        例 1：
        int a = 5;
        int b = 6;
        const int * const p = &a;
    
        //p = &b;   //error: assignment of read-only variable ‘p’
        //*p = 100;   //error: assignment of read-only variable ‘p’
        printf("p=%x, %x, %x\n", *p, p, &a);
        
        输出：
        p=5, 47cd24dc, 47cd24dc
        
        
        例 2：
        int a = 5;
        const int * const p;
        //p = &a;   //error: assignment of read-only variable ‘p’
    ```


3. 指针常量和常量指针有什么区别？
    - 常量指针
        示例：
        ```
        int a = 6;
        int const *p;
        p = &a;
        *p = 100;    //error assignment of read-only variable ‘p’
        ```
        
        定义： 又叫常指针，可以理解为常量的指针，也即这个是指针，但指向的是个常量。
        
        关键点：
        1.常量指针指向的对象不能通过这个指针来修改（\*p不能被赋值），可是仍然可以通过原来的声明修改（p = &a后，修改a的值）；
        2.常量指针可以被赋值为变量的地址（p=&a)，之所以叫常量指针，是限制了通过这个指针修改变量的值（\*p不能被赋值）；
        3.指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址（声明一个新变量b，p=&b指向b的地址）；
    
    - 指针常量
        示例：
        ```
        int a = 5;
        int b = 6;
        int *const p = &a;
        //p = &b;   //error: assignment of read-only variable ‘p’
        *p = 100;
        ```
        
        定义：本质是一个常量，而用指针修饰它。指针常量的值（指向的地址）是指针，这个值（指向的地址）因为是常量，所以不能被赋值。
        
        关键点：
        1.它是个常量，p = &a，用const修饰p，只能在初始化时定义p指向变量a的地址，再不能指向别的变量（如：b，p=&b，p不能被赋值）的地址。
        2.指针本身是常量，指向的地址不可以变化，但是指向的地址所对应的内容（\*p可以被赋值）可以变化；
    
    - 区别：
        常量指针是用const来修饰一个指针（int const \*p），而指针常量是用指针来修饰一个常量（int \*const p）；所以可以看\*和const的位置来区分：
        ```
       int const *p;    //常量指针，const修饰的是*p，所以*p不能被赋值修改，而p可以被修改指向新的地址
       const int *p;    //常量指针，同上
       int *const p;    //指针常量，const修饰的是p，所以p指向的地址不能被修改，而*p可以修改
        ```
        


4. static的作用是什么，什么情况下用到static？
    1. 函数体内，修饰局部变量时，在函数调用过程中保持变量值不变；
        
        > static修饰的局部变量保存在静态区（BSS段），在下一次调用的时候还可以保持原来的赋值
        
    2. 在一个模块（或单个代码文件中），修饰全局变量时，该变量只能被本模块（或所在代码文件）中的函数访问，其他模块（或代码文件）无法访问；
        
        > 全局变量本来就保存在静态区，static只是限制了变量的属性。初始化的全局变量保存在静态区的==数据段==，未初始化的全局变量保存在静态区的==BSS段==
        
    3. 在一个模块（或单个代码文件中），修饰函数时，该函数只能被本模块（或所在代码文件）中的函数调用，其他模块（或代码文件）无法访问；

    4. 在C++类中声明成员变量和成员函数？？？


5. 全局变量与局部变量的区别？
    - 作用域不同，
        - 全局变量：其作用范围是“整个工程”，只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量
        - 静态全局变量：使用 static 关键字修饰，也具有全局作用功能，和全局变量区别在于如果该程序包含多个文件，其作用范围仅在定义的那个文件，不能作用于其它文件，这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量
        - 局部变量：仅仅从定义的位置开始，到定义它的右花括号结束，只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回
        - 静态局部变量：局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，和局部变量的区别在于函数执行完也还存在
    
    - 生存周期不同
        - 全局变量：从程序开始到程序结束
        - 静态全局变量：从程序开始到程序结束
        - 局部变量：从定义开始到函数结束，函数调用后变量就被撤销，内存被回收
        - 静态局部变量：从程序开始到程序结束，static 修饰的局部变量其生存期从函数变为整个进程
    
    - 内存中的位置不同
        - 全局变量：全局（静态）存储区
        - 静态全局变量：全局（静态）存储区
        - 局部变量：存放在栈中，只有在所在函数被调用时才动态地为变量分配存储单元
        - 静态局部变量：全局（静态）存储区
    
    >注：
    >全局（静态）存储区：分为DATA段和BSS段。DATA段（全局初始化区）存放初始化的全局变量和全局静态变量；BSS段（全局未初始化区）存放未初始化的全局变量、静态全局变量和静态局部变量（初始化和未初始化的）。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态全局变量在程序执行之前已经为0。


6. 宏定义的作用是什么？
    
    宏定义是预处理命令的一种，一般用一个标识符（宏名）来表示一个数值变量或者字符串。在编译预处理时，对程序中所有出现该宏名称的地方用宏定义中的数值或者字符串替换，称为宏替换或者宏展开。
    >详细内容参考笔记：[宏定义详解](../../C,%20C++/C,%20C++基础/宏定义详解.md)


7. 内存对齐的概念？为什么会有内存对齐？
    
    **概念：** 一般需要考虑到数据对齐的地方是结构体和联合体的定义，因为这两个数据结构能定义不同类型的成员变量。所以内存对齐简单理解就是数据以指定的字节长度存储，32位操作系统默认4个字节，64位操作系统默认8个字节。也就是说在32位系统中，一个`char`类型的变量占用长度是4个字节，64位系统中占用8个字节，并且结构体或者联合体的第一个数据成员放在offset为0的地方。定义结构体时加上`__attribute__((aligned(n)))`可以用来指定结构体对齐的单位长度。
    
    **目的：** 操作系统读取数据是按固定长度为单位来存取数据，32位操作系统默认4个字节，64位操作系统默认8个字节。以32位操作系统为例，如果没有内存对齐，那么结构体或者联合体的某个成员变量可以在存放在地址0x1，那么读取数据时需要从0x0地址读取4个字节（0x0-0x3），剔除不需要的地址（0x0），然后从地址0x4读取4个字节（0x4-0x7），再剔除不需要的地址（0x5-0x7），最后将两次读取的数据进行拼接，效率明显存在问题。所以内存对齐机制能提高数据读取效率。
    
    **修改方法：** `#pragma pack(对齐系数)`，比如：`#pragma pack(8)`指定对齐长度为8个字节。
    


8. inline 内联函数的特点有哪些？它的优缺点是什么？
    - 相当于把内联函数里面的内容写在调用内联函数处；
    - 相当于不用执行进入函数的步骤，直接执行函数体；
    - 相当于宏，却比宏多了类型检查，真正具有函数特性；
    - 不能包含循环、递归、switch 等复杂操作；
    - 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。


9. 如何避免野指针？
    1）指针初始化，没有指向时，初始化为NULL
    2）给指向的空间赋值时，注意要分配内存空间
    3）malloc分配内存空间时，检查分配是否成功，memset初始化分配的空间
    4）使用指针时注意不要越界，比如操作指向数组的指针时
    5）使用完以分配内存的指针后，free释放内存空间，然后再次置NULL，避免指向已经释放的地址空间
    6）指针作为函数参数使用时，先检查是否为NULL


10. 如何计算结构体长度？
    根据结构体内最长的成员计算，其他成员占用空间长度按最长成员的长度进行偏移。如果有两个不同长度类型的成员，char和short，那么计算长度时short成员需要在char的地址上偏移2个字节，那么结构体长度就是4个字节；如果是char和int，那么int成员需要在char成员的地址上偏移4个字节，结构体长度就是8个字节；如果两个成员都是char类型，那结构体长度就是2个字节。


11. sizeof和strlen有什么区别？
    strlen是用来计算字符串长度的库函数，长度不包括字符串结尾的结束符`\0`。sizeof是一个运算符，长度包括结尾的结束符`\0`。


12. 知道条件变量吗？条件变量为什么要和锁配合使用？
    条件变量是一种线程间的通知机制，一个线程的执行需要某个条件成立，而这个条件的状态又在另一个线程中更新，条件变量就是这样一种等待+唤醒的机制。
    和锁配合使用是为了防止多个线程同时请求产生竞争，导致一些不可预知的情况。


13. 如何用C 实现 C++ 的面向对象特性（封装、继承、多态）
    

14. memcpy怎么实现让它效率更高？
    在内存不对齐时，memcpy是一个字节一个字节的拷贝。在内存对齐时，memcpy的效率已经足够高了。
    优化思路就是在拷贝时最大程度的增加单次拷贝的数据长度，比如4个字节或者8个字节，剩下不足4或8个字节的按单个字节拷贝补足。


15. typedef和define有什么区别？
    1）原理不同：
    typedef是关键字，在预编译阶段处理，具有类型检查功能。而define是预处理语法，在编译之前的预处理阶段进行简单的字符串替换，不作正确性检查
    
    2）功能不同：
    typedef用来定义类型的别名，甚至是定义函数的指针类型，而define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。
    比如下面的用法，typedef和define在这里的作用没什么区别，都是声明一个别名
    ```
    typedef int TEST_INT
    #define TEST_INT int
    ```
    但是，typedef不能这么简单的理解为与define在功能上差不多。typedef还可以声明一个函数指针类型，比如原函数为：
    ```
    void func(int para1, char para2);
    ```
    那么用typedef声明的函数指针为：
    ```
    typedef void (*test_func_t)(int para1, char para2);
    ```
    然后就可以用`test_func`这个类型来声明一个指向函数的指针：
    ```
    test_func_t g_func
    ```
    当g_func知道函数地址后，就可以像调用原函数func一样使用这个函数指针
    ```
    void func_register(void *function)
    {
        g_func = function;
    }
    
    #告知g_func原函数的地址
    func_register(func);
    
    #开始使用
    g_func(para1, para2);
    ```
    
    3）作用域不同：
    define没有作用域的限制，在一个函数内预定义的宏，在别的函数内也可以使用，typedef就不行，但是一般不在函数内部使用typedef
    
    4）对指针的操作不同：
    https://blog.csdn.net/yan_auvtech/article/details/5968761
    


16. extern有什么作用，extern C有什么作用？ 
    1）extern
    extern表示将变量或函数声明为外部链接，是函数和全局变量作用范围的关键字。C头文件里面定义了一个函数或变量，如果该函数或变量开放给外部，则在h文件中用extern加以声明。外部文件只include该.h文件就可以了。而且编译阶段，外面是找不到该函数的，但是不报错。link阶段会从定义模块生成的目标代码中找到此函数或变量。
    
    2）extern "C"
    extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。
    
    由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名（而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名）。
    
    也就是说：C++和C对产生的函数名字的处理是不一样的，extern "C"的目的就是主要实现C与C++的相互调用问题。



17. 在C++中调用被C编译器编译后的函数，为什么要加extern“C”？
    
    加上extern "C"后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。
    
    由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名（而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名）。
    
    也就是说：C++和C对产生的函数名字的处理是不一样的，extern "C"的目的就是主要实现C与C++的相互调用问题。


18. 不调用字符串库函数，如何实现 strcpy？
```
	while( (*strDest++ = * strSrc++) != ‘\0’ );
```


19. 传参时如何防止数组退化成指针？
    
	其实数组名本身就是指针，但是为什么数组变成指针叫退化呢，因为指针表示的是一个内存地址，数组也表示一个内存地址，但是数组表示的是一个数据结构的内存地址，数组包含的信息比指针多，数组变成了指针，这部分信息就丢失了，所以叫 “退化”。比如要在函数里面计算数组的 sizeof，数组退化成指针之后就会计算不到了。

	直接调用数组将退化为指针：`void func(int int_ref[10])`
	使用数组引用即可保护数组：`void each2(int (&int_ref)[10])`


20. volatile关键字
    忽略编译器的优化，必须每次去内存中取变量值


### 操作系统
- 进程和线程的区别？
- 操作系统是怎么进行进程管理的？
- 操作系统是如何做到进程阻塞的？
- 进程之间的通信方式有哪些？
- 线程是如何实现的？
- 线程之间私有和共享的资源有哪些？
- 一般应用程序内存空间的堆和栈的区别是什么？
- 进程虚拟空间是怎么布局的？
- 虚拟内存是如何映射到物理内存的？了解分页内存管理吗？
- 什么是上下文切换，操作系统是怎么做的上下文切换？
- 什么是大端字节，什么是小端字节？如何转换字节序？
- 产生死锁的必要条件有哪些？如何避免死锁？
- 信号和信号量的区别是什么？
- 锁的性能开销，锁的实现原理？


**编译原理，编译和链接的知识还是很重要的，解决编译和链接过程中的报错也是C++程序员的基本能力。**
- gcc hello.c 这行命令具体的执行过程，内部究竟做了什么？
- 程序一定会从main函数开始运行吗？
- 如何确定某个函数有被编译输出？
- 动态链接库和静态链接库的区别是什么？





